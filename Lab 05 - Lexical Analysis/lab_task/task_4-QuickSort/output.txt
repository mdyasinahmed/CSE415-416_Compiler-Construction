#include -> PREPROCESSOR
<stdio.h> -> HEADER_FILE
void -> VOID
swap -> ID
( -> LPAREN
int -> INT
* -> MUL
a -> ID
, -> COMMA
int -> INT
* -> MUL
b -> ID
) -> RPAREN
{ -> LBRACE
int -> INT
t -> ID
= -> ASSIGN
* -> MUL
a -> ID
; -> SEMI
* -> MUL
a -> ID
= -> ASSIGN
* -> MUL
b -> ID
; -> SEMI
* -> MUL
b -> ID
= -> ASSIGN
t -> ID
; -> SEMI
} -> RBRACE
int -> INT
partition -> ID
( -> LPAREN
int -> INT
arr -> ID
[ -> LBRACKET
] -> RBRACKET
, -> COMMA
int -> INT
low -> ID
, -> COMMA
int -> INT
high -> ID
) -> RPAREN
{ -> LBRACE
int -> INT
pivot -> ID
= -> ASSIGN
arr -> ID
[ -> LBRACKET
high -> ID
] -> RBRACKET
; -> SEMI
int -> INT
i -> ID
= -> ASSIGN
low -> ID
- -> SUB
1 -> NUMBER
; -> SEMI
for -> FOR
( -> LPAREN
int -> INT
j -> ID
= -> ASSIGN
low -> ID
; -> SEMI
j -> ID
< -> LT
high -> ID
; -> SEMI
j -> ID
++ -> INC
) -> RPAREN
{ -> LBRACE
if -> IF
( -> LPAREN
arr -> ID
[ -> LBRACKET
j -> ID
] -> RBRACKET
<= -> LE
pivot -> ID
) -> RPAREN
{ -> LBRACE
i -> ID
++ -> INC
; -> SEMI
swap -> ID
( -> LPAREN
& -> ADDRESS
arr -> ID
[ -> LBRACKET
i -> ID
] -> RBRACKET
, -> COMMA
& -> ADDRESS
arr -> ID
[ -> LBRACKET
j -> ID
] -> RBRACKET
) -> RPAREN
; -> SEMI
} -> RBRACE
} -> RBRACE
swap -> ID
( -> LPAREN
& -> ADDRESS
arr -> ID
[ -> LBRACKET
i -> ID
+ -> ADD
1 -> NUMBER
] -> RBRACKET
, -> COMMA
& -> ADDRESS
arr -> ID
[ -> LBRACKET
high -> ID
] -> RBRACKET
) -> RPAREN
; -> SEMI
return -> RETURN
i -> ID
+ -> ADD
1 -> NUMBER
; -> SEMI
} -> RBRACE
void -> VOID
quickSort -> ID
( -> LPAREN
int -> INT
arr -> ID
[ -> LBRACKET
] -> RBRACKET
, -> COMMA
int -> INT
low -> ID
, -> COMMA
int -> INT
high -> ID
) -> RPAREN
{ -> LBRACE
if -> IF
( -> LPAREN
low -> ID
< -> LT
high -> ID
) -> RPAREN
{ -> LBRACE
int -> INT
pi -> ID
= -> ASSIGN
partition -> ID
( -> LPAREN
arr -> ID
, -> COMMA
low -> ID
, -> COMMA
high -> ID
) -> RPAREN
; -> SEMI
quickSort -> ID
( -> LPAREN
arr -> ID
, -> COMMA
low -> ID
, -> COMMA
pi -> ID
- -> SUB
1 -> NUMBER
) -> RPAREN
; -> SEMI
quickSort -> ID
( -> LPAREN
arr -> ID
, -> COMMA
pi -> ID
+ -> ADD
1 -> NUMBER
, -> COMMA
high -> ID
) -> RPAREN
; -> SEMI
} -> RBRACE
} -> RBRACE
int -> INT
main -> MAIN
( -> LPAREN
) -> RPAREN
{ -> LBRACE
int -> INT
arr -> ID
[ -> LBRACKET
] -> RBRACKET
= -> ASSIGN
{ -> LBRACE
10 -> NUMBER
, -> COMMA
7 -> NUMBER
, -> COMMA
8 -> NUMBER
, -> COMMA
9 -> NUMBER
, -> COMMA
1 -> NUMBER
, -> COMMA
5 -> NUMBER
} -> RBRACE
; -> SEMI
int -> INT
n -> ID
= -> ASSIGN
sizeof -> ID
( -> LPAREN
arr -> ID
) -> RPAREN
/ -> DIV
sizeof -> ID
( -> LPAREN
arr -> ID
[ -> LBRACKET
0 -> NUMBER
] -> RBRACKET
) -> RPAREN
; -> SEMI
quickSort -> ID
( -> LPAREN
arr -> ID
, -> COMMA
0 -> NUMBER
, -> COMMA
n -> ID
- -> SUB
1 -> NUMBER
) -> RPAREN
; -> SEMI
for -> FOR
( -> LPAREN
int -> INT
i -> ID
= -> ASSIGN
0 -> NUMBER
; -> SEMI
i -> ID
< -> LT
n -> ID
; -> SEMI
i -> ID
++ -> INC
) -> RPAREN
printf -> PRINTF
( -> LPAREN
" -> UNKNOWN
% -> MOD
d -> ID
" -> UNKNOWN
, -> COMMA
arr -> ID
[ -> LBRACKET
i -> ID
] -> RBRACKET
) -> RPAREN
; -> SEMI
return -> RETURN
0 -> NUMBER
; -> SEMI
} -> RBRACE
